\documentclass{article}
\title{How to Use Player/Stage}
\author{Jennifer Owen}
\begin{document}

\maketitle
Player/Stage is a robot simulation tool, it comprises of one program, Player, which is an interface to your robot's devices. That means that it can talk to all the bits of hardware on the robot (like a claw or a camera)  and lets you control them using code without having to worry about how it actually talks to the hardware. Stage is a plugin to Player which makes a simulation of your robot. If you use Stage, then Player will talk to Stage as if it were a robot telling it what to do and where to go, Stage then converts these instructions into a simulation. Stage returns information about what the simulated robot is sensing to Player so that Player can give this information to your code in order to decide what the robot should do next.

The simulation then, is composed of three parts:
\begin{itemize}
\item Your code. This talks to Player.
\item Player. This takes your code and sends instructions to a robot. From the robot it gets sensor data and sends it to your code.
\item Stage. Stage interfaces with Player in the same way as a robot would. It recieves instructions from Player and moves a simulated robot in a simulated world, it gets sensor data from the robot in the simulation and sends this to Player.
\end{itemize}
Together Player and Stage are called Player/Stage, and they make a simulation of your robots.

In these instructions I will be focussing on how to use Player/Stage to make a simulation but hopefully this will still be a useful resource for anyone just using Player.

\section{The Basics}

\subsection{Interfaces, Drivers and Devices}
Drivers are pieces of code that talk directly to hardware. These are built in to Player so it is not important to know how to write these as you begin to learn Player/Stage. The drivers are specific to a piece of hardware so, say, a laser driver be different to a sonar driver, and also different to a driver for a different brand laser. This is the same as the way that drivers for graphics cards differ for each make and model of card. The official Player documentation says this about drivers:\newline
\emph{driver : A piece of software (usually written in C++) that talks to a robotic sensor, actuator, or algorithm, and translates its inputs and outputs to conform to one or more interfaces. The driver's job is hide the specifics of any given entity by making it appear to be the same as any other entity in its class. }\newline

Interfaces are a set way for a driver to send and receive information from Player. Interfaces are also built in to Player and there is a big list of them which I will no doubt describe later. The official Player documentation says this about interfaces:\newline
\emph{interface : A specification of how to interact with a certain class of robotic sensor, actuator, or algorithm. The interface defines the syntax and semantics of all messages that can be exchanged with entities in the same class.}\newline

A device is a driver that is bound to an interface so that Player can talk to it directly. This means that if you are working on a real robot that you can interact with a real device (laser, gripper, camera etc) on the real robot, in a simulated robot you can interact with their simulations. The official Player documentation says this about devices:\newline
\emph{device : A driver bound to an interface, and given a fully-qualified address. All messaging in Player occurs among devices, via interfaces. The drivers, while doing most of the work, are never accessed directly.}

The official documentation actually describes these 3 things quite well with an example.

\emph{
Consider the laser interface. This interface defines a format in which a planar range-sensor can return range readings (basically a list of ranges, with some meta-data). The laser interface is just that: an interface. You can't do anything with it.

Now consider the sicklms200 driver. This driver controls a SICK LMS200, which is particular planar range sensor that is popular in mobile robot applications. The sicklms200 driver knows how to communicate with the SICK LMS200 over a serial line and retrieve range data from it. But you don't want to access the range data in some SICK-specific format. So the driver also knows how to translate the retrieved data to make it conform to the format defined by the laser interface.

The sicklms200 driver can be bound to the laser interface \ldots to create a device, which might have the following address:

localhost:6665:laser:0

The fields in this address correspond to the entries in the player_devaddr_t structure: host, robot, interface, and index. The host and robot fields (localhost and 6665) indicate where the device is located. The interface field indicates which interface the device supports, and thus how it can be used. Because you might have more than one laser, the index field allows you to pick among the devices that support the given interface and are located on the given host:robot Other lasers on the same host:robot would be assigned different indexes.
}



\subsection{Important File Types}
In Player/Stage there are 3 kinds of file that you need to understand to get going:
\begin{itemize}
\item a .world file
\item a .cfg file
\item a .inc file
\end{itemize}
The .world file tells Player/Stage what things are available to put in the world. In this file you describe your robot, any items which populate the world and the layout of the world.

The .cfg file is what Player reads to get all the information about the robot that you are going to use. You may or may not choose to use all the items available or all the parts of the robot, so this file tells the simulator what you want to use at this time. This file also tells Player what drivers to use to talk to the robot with. If you're using a real robot these drivers are built in to Player\footnote{Or you can download or write your own drivers, but I'm not going to talk about how to do this here.}, alternatively, if you want to make a simulation, the driver is always Stage (this is how Player uses Stage in the same way it uses a robot: it thinks that it is a hardware driver).









\section{Building a World}

\subsection{Building an Empty World}

\subsection{Building a Robot}

\subsection{Building other Stuff}













\begin{thebibliography}
\bibitem{playermanual}

\end{thebibliography}



\end{document}
